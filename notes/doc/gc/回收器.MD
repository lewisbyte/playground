
# GC回收器

### 理论派的经典算法

- v1：引用计数算法：优点：简单，缺点：无法回收有循环相互引用的对象
- v2：gcroot：优化了引用计数算法，添加了可达性分析算法，解决了对象循环引用的场景
- GC root 如何实现：JVM 会维护一个oopMap来更新、查询对象的引用状态，从而实现快速的对象引用状态的判断

### 垃圾收集算法
- v3：标记-清除算法：标记已经不会使用的对象，然后将这个对象回收，缺点：会有大量的内存碎片
- v4：（适用于年轻代）复制算法：开辟2块相同大小的内存片（s0,s1），每次回收前，将活着的对象复制到交换的内存片（s0->s1,s1->s0），复制后的交换区是顺序的、连续的内存。这样可以有效解决内存碎片的问题
- v5：（适用于老年代）标记-整理算法：复制算法缺点是需要开辟额外空间，而且还需要有分配担保的内存空间。标记-整理则是将存活的对象向一端移动，然后清理掉端边界以外的对象。



## 回收器

### 年轻代收集器
- parnew：延时敏感的年轻代收集器（多线程收集）
- serial：串行收集器（单线程收集）
- parallel scavenge：吞吐量敏感的年轻代收集器（多线程收集）

### 老年代收集器
- cms：并发标记清理，cms 如果出现"current mode failure"，将会启动serial old 收集器回收（多线程收集）
- serial old：串行标记（单线程收集）
- parallel old：并发标记清理，与parallel scavenge 搭配使用（多线程收集）


### 回收器的组合关系及相关的应用场景
- 延时不敏感，吞吐量优先，如批量大数据处理场景：parallel scavenge（年轻代） + parallel old （老年代） 
- 延时敏感，如用户的实时接口场景：parnew （年轻代）+ cms （老年代）
- 单核机器的客户端推荐：serial + serial old


### G1（年轻代+老年代 通吃策略，低延时的场景）

- 将内存划分为多个region，保留新生代、老年代的概念，但是之间不再有物理隔离，他们都是一部分的region，所以这里G1将回收年轻+老年代
- 特性：并发与并行、分代回收、空间整合（可以提供无内存碎片的回收，将内存化零为整）、可预测的停顿
- 收集策略：追踪各个region的垃圾堆积的价值大小：维护一个优先列表，优先回收价值大的Region
- 




## 分配担保

