
### 理论派的经典算法

- v1：引用计数算法：优点：简单，缺点：无法回收有循环相互引用的对象
- v2：gcroot：优化了引用计数算法，添加了可达性分析算法，解决了对象循环引用的场景
- GC root 如何实现：JVM 会维护一个oopMap来更新、查询对象的引用状态，从而实现快速的对象引用状态的判断

# 垃圾收集算法
- v3：标记-清除算法：标记已经不会使用的对象，然后将这个对象回收，缺点：会有大量的内存碎片
- v4：（适用于年轻代）复制算法：开辟2块相同大小的内存片（s0,s1），每次回收前，将活着的对象复制到交换的内存片（s0->s1,s1->s0），复制后的交换区是顺序的、连续的内存。这样可以有效解决内存碎片的问题
- v5：（适用于老年代）标记-整理算法：复制算法缺点是需要开辟额外空间，而且还需要有分配担保的内存空间。标记-整理则是将存活的对象向一端移动，然后清理掉端边界以外的对象。



# 回收器

### 年轻代收集器
- parnew
- serial
- parallel scavenge

### 老年代收集器
- cms
- serial old
- parallel old

## 回收器的组合关系及相关的应用场景
- 延时不敏感，吞吐量优先，如批量大数据处理场景：parallel scavenge（年轻代） + parallel old （老年代） 
- 延时敏感，如用户的实时接口场景：parnew （年轻代）+ cms （老年代）
- 单核机器的客户端推荐：serial + serial old




## 分配担保

